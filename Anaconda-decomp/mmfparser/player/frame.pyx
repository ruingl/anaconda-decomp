# Copyright (c) Mathias Kaerlev 2012.

# This file is part of Anaconda.

# Anaconda is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# Anaconda is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with Anaconda.  If not, see <http://www.gnu.org/licenses/>.

from mmfparser.player.collision cimport collides, ObjectCollisionfrom mmfparser.player.objects.common cimport BackgroundPlayerfrom mmfparser.player.transitions import get_transitionfrom mmfparser.player.eventdispatcher import EventDispatcherfrom mmfparser.data.chunkloaders.objectinfo import (QUICKBACKDROP, BACKDROP,    ACTIVE, TEXT, COUNTER, SCORE, LIVES, EXTENSION_BASE)from mmfparser.data.chunkloaders.objects import (LADDER_OBSTACLE,     SOLID_OBSTACLE, NONE_OBSTACLE, FINE_COLLISION)from mmfparser.data.chunkloaders.frame import NONE_PARENTfrom pyglet.gl import (glDisable, GL_TEXTURE_2D, GL_QUADS, glPushAttrib,    glPopAttrib, GL_COLOR_BUFFER_BIT, glClear, glClearColor, glPushMatrix,    glPopMatrix, glTranslatef, GL_DEPTH_BUFFER_BIT,    glEnable, GL_SCISSOR_TEST, glLoadIdentity)from pyglet import graphicscdef inline draw_instance_offset(Instance instance, int offsetX, int offsetY):    glPushMatrix()    glTranslatef(offsetX, offsetY, 0)    instance.draw()    glPopMatrix()cdef class Layer(PlayerChild):    def initialize(self, layer):        self.instances = []        self.instanceHandles = {}        self.backgrounds = set()        self.backInstances = []        self.obstacles = []        self.ladders = []        self.name = layer.name        self.flags = layer.flags        self.xCoefficient = layer.xCoefficient        self.yCoefficient = layer.yCoefficient        self.wrapX = self.flags['WrapHorizontally']        self.wrapY = self.flags['WrapVertically']        self.visible = not self.flags['ToHide']        def set_position(self, int x = 0, int y = 0):        cdef int newX, newY        newX = x - self.x        newY = y - self.y        self.x = x        self.y = y        for instances in (self.instances, self.backInstances):            for instance in instances:                if instance.scroll:                    instance.set_position(instance.x + newX, instance.y + newY)            cpdef add(self, Instance instance, bint asBackground = False):        if asBackground:            if instance.handle in self.player.frame.backgrounds:                self.backgrounds.add(instance)            self.backInstances.append(instance)            if instance.objectType in (QUICKBACKDROP, BACKDROP):                obstacleType = instance.objectPlayer.obstacleType                if obstacleType == LADDER_OBSTACLE:                    self.ladders.append(instance)                elif obstacleType == SOLID_OBSTACLE:                    self.obstacles.append(instance)        else:            handle = instance.handle            if handle not in self.instanceHandles:                self.instanceHandles[handle] = set()            (<set>self.instanceHandles[handle]).add(instance)            self.instances.append(instance)        cpdef remove(self, Instance instance):        try:            self.instances.remove(instance)            (<set>self.instanceHandles[instance.handle]).discard(instance)        except ValueError:            self.backInstances.remove(instance)            self.backgrounds.discard(instance)            if instance in self.ladders:                self.ladders.remove(instance)            elif instance in self.obstacles:                self.obstacles.remove(instance)        cpdef bint has_instance(self, Instance instance):        return instance in self.instances        cpdef set_level(self, Instance instance, int level):        if level < 0:            level = 0        self.instances.remove(instance)        self.instances.insert(level, instance)        cpdef set_instances(self, list instances):        if len(instances) != len(self.instances):            raise ValueError('missing instances for new order')        self.instances = instances        cpdef int get_level(self, Instance instance):        return self.instances.index(instance)        cpdef int get_size(self):        return len(self.instances)            cpdef tuple ladder_at(self, int x, int y):        cdef int x1, y1, x2, y2        cdef Instance item        for item in self.ladders:            x1, y1, x2, y2 = item.x1, item.y1, item.x2, item.y2            if collides(x, y, x + 1, y + 1, x1, y1, x2, y2):                return x1, y1, x2, y2        return None            cpdef draw(self):        if not self.visible:            return        cdef Instance instance                cdef int width = (<Frame>self.parent).width        cdef int height = (<Frame>self.parent).height                cdef int x1, y1, x2, y2                if self.wrapX or self.wrapY:            for instance in self.backInstances:                if instance.objectType in (QUICKBACKDROP, BACKDROP):                    glPushMatrix()                    if self.wrapX:                        glTranslatef(                            <int>((self.player.x1 - instance.x1) / width) * width,                            0, 0)                    if self.wrapY:                        glTranslatef(                            0,                             <int>(-(self.player.y1 - instance.y1) / height) * height,                            0)                    instance.draw()                    if self.wrapX:                        draw_instance_offset(instance, width, 0)                    if self.wrapY:                        draw_instance_offset(instance, 0, -height)                    if self.wrapX and self.wrapY:                        draw_instance_offset(instance, width, -height)                    glPopMatrix()                else:                    instance.draw()        else:            for instance in self.backInstances:                instance.draw()        for instance in self.instances:            instance.draw()cdef class Frame(PlayerChild):    def initialize(self, frame):        self.startingUp = True        self.loader = frame        self.width = frame.width        self.height = frame.height        virtualRight = frame.right        if virtualRight == -1:            virtualRight = 0x7FFFF000        virtualBottom = frame.bottom        if virtualBottom == -1:            virtualBottom = 0x7FFFF000        self.virtualWidth = virtualRight - frame.left        self.virtualHeight = virtualBottom - frame.top        r, g, b = frame.background        self.set_background_color(r, g, b)        self.objectCount = 0        self.maxObjects = frame.maxObjects                self.collisionDict = {}        self.stopDict = {}        self.backgroundCollisions = set()        self.backgroundStops = set()        self.backgrounds = set()        self.objectHandlers = {}        self.noSleepHandles = set()        self.borderCollisionHandles = set()                self.layers = []                cdef Layer newLayer                for layer in frame.layers.items:            newLayer = self.new(Layer)            newLayer.initialize(layer)            self.layers.append(newLayer)        self.instances = []        self.instanceHandles = {}        self.pastedInstances = []                self.topRenders = []                self.timeChangeHandlers = []                if frame.instances:            for item in frame.instances.items:                if item.parentType != NONE_PARENT:                    continue                self.create_instance(item)                if frame.fadeIn:            self.fadeIn = self.new(get_transition(frame.fadeIn))            self.fadeIn.initialize(frame.fadeIn, self.fade_in_finished)            self.player.fading = True                self.startingUp = False        self.startTime = self.player.get_time()        cdef void update(self):        cdef Instance instance        for instance in self.instances:            instance.update()        def set_background_color(self, r, g, b):        self.clearValue = (r / 255.0, g / 255.0, b / 255.0, 1.0)        def set_size(self, width = None, height = None):        if width is not None:            if self.width == self.virtualWidth:                self.virtualWidth = width            self.width = width        if height is not None:            if self.height == self.virtualHeight:                self.virtualHeight = height            self.height = height        def set_virtual_size(self, width = None, height = None):        if width is not None:            self.virtualWidth = width        if height is not None:            self.virtualHeight = height        def get_time(self):        return self.player.get_time() - self.startTime        def create_instance(self, item, *arg, **kw):        if self.objectCount >= self.maxObjects:            return None        cdef Instance newItem = self.new(Instance)        cdef int handle = item.objectInfo        self.instances.append(newItem)        if handle not in self.instanceHandles:            self.instanceHandles[handle] = []        self.instanceHandles[handle].append(newItem)        newItem.initialize(item, *arg, **kw)        if newItem.destroyed and self.startingUp:            self.instances.remove(newItem)            self.instanceHandles[handle].remove(newItem)            return None        if newItem.objectType not in (QUICKBACKDROP, BACKDROP):            self.objectCount += 1        return newItem        def paste_sprite(self, sprite, collisionType, layerIndex):        layer = self.layers[layerIndex]        cdef Instance newItem = self.new(PastedInstance)        newItem.initialize(sprite, collisionType, layer)        self.pastedInstances.append(newItem)        layer.add(newItem, True)        def register_stop_collision(self, objectInfo, otherInfo):        cdef set collisionList        try:            collisionList = self.stopDict[objectInfo]            collisionList.add(otherInfo)        except KeyError:            self.stopDict[objectInfo] = set([otherInfo])            def register_background_collision(self, objectInfo):        if objectInfo not in self.backgroundCollisions:            self.backgroundCollisions.add(objectInfo)            self.noSleepHandles.add(objectInfo)        def register_background_stop_collision(self, objectInfo):        self.backgroundStops.add(objectInfo)        def register_collision(self, objectInfo, otherInfo):        cdef dict collisionDict = self.collisionDict        cdef set collisionList        self.noSleepHandles.add(objectInfo)        self.noSleepHandles.add(otherInfo)        for first, second in ((objectInfo, otherInfo), (otherInfo, objectInfo)):            try:                collisionList = self.collisionDict[first]                collisionList.add(second)            except KeyError:                collisionDict[first] = set([second])    def add_background(self, Instance instance):        self.backgrounds.add(instance.handle)        def add_no_sleep_instance(self, objectInfo):        self.noSleepHandles.add(objectInfo)        def add_border_collision_instance(self, objectInfo):        self.borderCollisionHandles.add(objectInfo)        cpdef bint collision_enabled(self, objectInfo):        return (objectInfo in self.collisionDict             or objectInfo in self.backgroundCollisions)        cpdef set get_collision_instances(self, Instance instance):        objectInfo = instance.handle        cdef set otherInfos        cdef Layer layer = instance.layer        if objectInfo in self.collisionDict:            otherInfos = self.collisionDict[objectInfo]        else:            otherInfos = set()        cdef set instances = set()        for handle in otherInfos:            if handle in layer.instanceHandles:                instances |= (<set>layer.instanceHandles[handle])        if objectInfo in self.backgroundCollisions:            instances |= layer.backgrounds        return instances        cpdef set get_stop_instances(self, Instance instance):        objectInfo = instance.handle        cdef set otherInfos        cdef Layer layer = instance.layer        if objectInfo in self.stopDict:            otherInfos = self.stopDict[objectInfo]        else:            otherInfos = set()        cdef set instances = set()        for handle in otherInfos:            if handle in layer.instanceHandles:                instances |= (<set>layer.instanceHandles[handle])        if objectInfo in self.backgroundStops:            instances |= layer.backgrounds        return instances        def instances_from_name(self, str name):        return [instance for instance in self.instances            if instance.objectInfo.name and instance.objectInfo.name.count(                name)]        def destroy_instance(self, item):        self.objectCount -= 1        self.instances.remove(item)        self.instanceHandles[item.handle].remove(item)        item.fire_handler('destroyed')        def add_handlers(self, handle, **kw):        cdef EventPlayer eventPlayer = self.player.eventPlayer        for objectInfo in eventPlayer.resolve_objects(handle):            if objectInfo not in self.objectHandlers:                self.objectHandlers[objectInfo] = {}            handlerDict = self.objectHandlers[objectInfo]            for k, v in kw.iteritems():                if not k in handlerDict:                    handlerDict[k] = []                if v not in handlerDict[k]:                    handlerDict[k].append(v)        def fire_handler(self, instance, eventType, *args):        try:            handlers = self.objectHandlers[instance.handle][                eventType]            for handler in handlers:                handler(instance, *args)        except KeyError:            pass        cdef list get_instances(self, handle):        if handle in self.instanceHandles:            return self.instanceHandles[handle]        return []        def get_fixed_object(self, fixed):        cdef Instance instance        for instance in self.instances:            if id(instance) == fixed:                return instance        return None        def fade_in_finished(self):        self.fadeIn = None        self.player.fading = False        def fade_out_finished(self):        self.player.fading = False        self.player.fade_out_finished()        def fade_out(self):        fade = self.loader.fadeOut        if self.fadeOut is not None or self.fadeIn is not None:            return False        elif fade is not None:            self.fadeOut = self.new(get_transition(fade))            self.fadeOut.initialize(fade, self.fade_out_finished)            self.player.fading = True            return True        return False        def draw(self, bint draw_window = True):        cdef Layer layer        if self.player.fading and draw_window:            if self.fadeIn:                self.fadeIn.draw()            elif self.fadeOut:                self.fadeOut.draw()        else:            # draw background            glClearColor(*self.clearValue)            glClear(GL_COLOR_BUFFER_BIT)                        for layer in self.layers:                layer.draw()                        for handler in self.topRenders:                handler()        cpdef on_detach(self):        self.objectHandlers = None        self.timeChangeHandlers = Nonecdef class PastedPlayer(BackgroundPlayer):    cdef public:        cdef object sprite        cdef object obstacleType    cdef void initialize_pasted(self, sprite, collisionType):        self.sprite = sprite        cdef ObjectCollision collision = sprite.collision        collision.parent = self.parent        collision.objectPlayer = self        self.collision = collision        self.obstacleType = collisionType        if collisionType not in (NONE_OBSTACLE, LADDER_OBSTACLE):            self.player.frame.add_background(self.parent)    cpdef bint draw(self):        self.sprite.render()        cpdef on_detach(self):        self.collision = None        self.sprite = Nonecdef class PastedInstance(Instance):    def initialize(self, sprite, collisionType, layer):        self.layer = layer        self.layerIndex = self.player.frame.layers.index(layer)        self.objectPlayer = self.new(PastedPlayer)        (<PastedPlayer>self.objectPlayer).initialize_pasted(sprite,             collisionType)        self.objectType = BACKDROP        self.x1, self.y1, self.x2, self.y2 = sprite.get_rect()        self.boxSet = True        self.visible = True        self.scroll = True    def destroy(self, forced = False):        self.destroying = True        self.layer.remove(self)        self.parent.pastedInstances.remove(self)        self.detach()